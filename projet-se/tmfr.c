/** \file
 * tmfr.c : teste le maquefilereader
 * \copyright Vincent Loechner, 2014.
 */

#include "maquefilereader.h"
#include "tmfr.h"
#include <sys/time.h>

/** main
 * ouvre un fichier maquefile passé en argument, l'analyse et construit
 * la première cible ou le cas échéant la cible passée en argument.
 */

Noeud* executer(Noeud* n, int t)
{
	int i = 0;
	int pid;
	int status;
	if(t == 1){
		struct timeval tvDebut;
		gettimeofday(&tvDebut, NULL);
		n->t_exec = tvDebut.tv_sec*1000000+tvDebut.tv_usec;
	}
	while((n->commandes != NULL) && (n->commandes[i]))
	{

		pid = fork();
		//execution des commandes dans le fils
		if(pid > 0)
		{
			execl("/bin/sh", "/bin/sh", "-c", n->commandes[i], NULL);
		}	
		//sinon on attend (père)
		else
		{
			waitpid(pid, &status, 0);
			n->flag += 1;
		}
		i++;
	}
	if(t == 1){
		struct timeval tvFin;
		gettimeofday(&tvFin, NULL);
		//Calcul le temps d'exécution 
		n->t_exec = n->t_exec - (tvFin.tv_sec*1000000+tvFin.tv_usec);
		printf("Temps d'exécution de la cible %s : %ld \n", n->nom, n->t_exec);
	}
	return n;	
}

Graphe* maqueGeneral(Graphe *tmp, int t)
{
	//variable permettant de définir la fin de la boucle
	int fb = 0;
	//tant qu'il y a des noeuds a analyser
	while(fb != 1)
	{
		//id du premier fork
		int pid;
		int status;	
		pid = fork();
		switch(pid)
		{
			case -1: 	
				perror("Erreur lors de l'exécution du fork");
				break;
			case 0:
				tmp->n = executer(tmp->n, t);
			//Attendre la fin du fils avant de passer au noeud suivant
			default:
				sleep(1);
				waitpid(pid, &status, 0);
				break;
 		}
 		//passage au noeud suivant
		if(tmp->suiv != NULL)
			tmp=tmp->suiv;
		else
			fb = 1;
	}
	return tmp;
}

Noeud* maqueSpecifique(Noeud* node, int t)
{
	//S'il n'y a pas de prédecesseur
	if(node->pred == NULL)
	{
		node = executer(node, t);
	}
	else
	{
		//Liste des prédecesseurs
		Liste* p = node->pred;
		//Int gérant l'arrêt de la boucle
		int fb = 0;
		while(fb == 0)
		{
			//S'ils ne l'ont pas été alors exec
			if(p->n->flag == 0)
				maqueSpecifique(p->n, t);
			//Tant qu'il y a des prédecesseurs
			if(p->suiv != NULL)
				p = p->suiv;
			else
				fb = 1;
		}
		//Exécution des commandes du noeud courant
		node = executer(node, t);
	}
	return node;
}

ElemN * AjoutPile(ElemN * pile, Noeud * n)
{
	ElemN * newP = malloc(sizeof(ElemN));
	newP->n = n;
	newP->next = pile;
	return newP;
}

void AjoutFile(ElemP ** file, ElemN * pileNode)
{
	ElemP * newfile = malloc(sizeof(ElemP *));
	if(newfile == NULL)
	{
		perror("malloc de newfile");
		exit(1);
	}
	newfile->next = NULL;
	newfile->pileNode = pileNode;
	if(*file == NULL) //first elem
	{
		*file = newfile;
	}
	else //ajout en fin de file
	{
		ElemP * tmp_file = *file;
		while(tmp_file->next != NULL)
			tmp_file = tmp_file->next;
		tmp_file->next = newfile;
	}
}

int dependof(Noeud * n, ElemN * pile)
{
	Liste * succ = malloc(sizeof(Liste *));
	ElemN * tmp_pile = malloc(sizeof(ElemN *));
	if(tmp_pile == NULL)
	{
		perror("malloc de tmp_pile");
		exit(1);
	}
	tmp_pile = pile;
	int end = 0;
	if(tmp_pile == NULL) //pile vide
		return 0;
	if(succ == NULL)
	{
		perror("malloc de succ (Liste)");
		exit(1);
	}

	while(!end) //on parcours la pile
	{
		succ = tmp_pile->n->succ;
		while(succ != NULL) //on parcours tout les successeurs
		{
			if(strcmp(n->nom, succ->n->nom) == 0)
				return 1;
			if(succ->suiv != NULL)
				succ = succ->suiv;
			else
				succ = NULL;
		}
		if(tmp_pile->next != NULL)
			tmp_pile = tmp_pile->next;
		else
			end = 1;
	}
	return 0; //n ne dépend d'aucun élement de pile
}

ElemP * constructFile(Graphe * tmp)
{
	ElemP * res = NULL;
	ElemN * tetepileNoeud = NULL;
	while(tmp != NULL)
	{
		/* Si le noeud dépend d'un des noeud du niveau */
		if(dependof(tmp->n, tetepileNoeud)) 
		{
			//changement de niveau
			AjoutFile(&res, tetepileNoeud);
			tetepileNoeud = NULL;
		}
		tetepileNoeud = AjoutPile(tetepileNoeud, tmp->n);
		tmp = tmp->suiv;
	}
	return res;
}


int maqueParallel(int nbprocs, Graphe * tmp, int t)
{
	ElemP * file = malloc(sizeof(ElemP));
	if(file == NULL)
	{
		perror("malloc de file");
		exit(1);
	} 
	file = constructFile(tmp);
	ElemN * Piletmp = malloc(sizeof(ElemN));
	if(Piletmp == NULL)
	{
		perror("malloc de Piletmp");
		exit(1);
	}
	int end = 0, i, nbproclance;
	pid_t * pids = malloc(sizeof(pid_t)* nbprocs);
	int changelevel = 0;

	//on initialise l'execution au premier niveau
	Piletmp = file->pileNode;
	while(!end)
	{
		nbproclance = 0;
		if(changelevel)
		{
			if(file->next != NULL) //passage au niveau suivant
			{
				file = file->next;
				Piletmp = file->pileNode;
				changelevel = 0;
			}
			else //on a executé le dernier niveau
			{
				end = 1;
			}
		}
		for(i = 0; i < nbprocs; i++) //Si le nombre d'exec > nbprocs, on passera deux fois dans cette boucle
		{
			switch(pids[i] = fork())
			{
				case 0: //fils
					executer(Piletmp->n, t);
					exit(1);
					break;
				case -1:
					perror("Erreur lors du fork");
					break;
				default: //père
					nbproclance++;
					break;
			}	
			if(Piletmp->next != NULL) //d'autre noeud à ce niveau
				Piletmp = Piletmp->next;
			else //on a lancé toutes les executions de ce niveau
			{
				i = nbprocs;
				changelevel = 1;
			}
		}
		for(i = 0; i < nbproclance; i++)
		{
			waitpid(pids[i], 0, 0);
			nbproclance--;
		}
	}
	return 1;
}

int main( int argc, char **argv )
{
	char *maquefile="Maquefile.test3"; /* nom du maquefile par défaut */
	int numproc = 1;
	int opt;
	int t = 0;
	Noeud *ncible;

	/* analyse des arguments */
	while( (opt=getopt( argc, argv, "j:f:T")) != -1 )
	{
		switch( opt )
		{
			case 'j':
				numproc = atoi(optarg);
				break;
			case 'f':
				maquefile = optarg;
				break;
			case 'T':
				t = 1;
				break;
			default:
				fprintf( stderr,
					"Usage: %s [-j nbprocs] [-f filename] [target]\n",
					argv[0] );
				exit(2);
		}
	}

	/* lecture du maquefile */
	Graphe *g;
	g = LireMaquefile( maquefile );
	if( g == NULL )
		exit( 1 );

	/* target */
	if( optind >= argc )
	{
		/* pas de cible spécifiée,
		 * on prend la dernière de la liste des noeuds du graphe */
		Graphe *tmp;
		tmp=g;

		/*tmp = maqueGeneral(tmp);*/
		maqueParallel(numproc, tmp, t);
		ncible = tmp->n;
	}
	else
	{
		/* on cherche la cible spécifiée */
		char *target;
		target = argv[optind];
		if( (ncible = TrouveNoeud(g, target )) == NULL )
		{
			fprintf( stderr, "No rule to make target '%s'.\n", target );
			exit( 2 );
		}
		else
		{
			ncible = maqueSpecifique(ncible, t);
		}
	}

	printf( "Making. Number of procs: %d; maquefile: %s; target:%s\n",
			numproc, maquefile, ncible->nom );

	//AfficheGraphe( g );

	FreeGraphe( g );

	return( 0 );
}
