/** \file
 * tmfr.c : teste le maquefilereader
 * \copyright Vincent Loechner, 2014.
 */

#include "maquefilereader.h"
#include "tmfr.h"
/** main
 * ouvre un fichier maquefile passé en argument, l'analyse et construit
 * la première cible ou le cas échéant la cible passée en argument.
 */

Noeud* executer(Noeud* n)
{
	int i = 0;
	int pid;
	int status;
	//
	while((n->commandes != NULL) && (n->commandes[i]))
	{
		pid = fork();
		//execution des commandes dans le fils
		if(pid > 0)
		{
			execl("/bin/sh", "/bin/sh", "-c", n->commandes[i], NULL);
		}	
		//sinon on attend (père)
		else
		{
			waitpid(pid, &status, 0);
			n->flag += 1;
		}
		i++;
	}
	return n;	
}

Graphe* maqueGeneral(Graphe *tmp)
{
	//variable permettant de définir la fin de la boucle
	int fb = 0;
	//tant qu'il y a des noeuds a analyser
	while(fb != 1)
	{
		//id du premier fork
		int pid;
		int status;	
		pid = fork();
		switch(pid)
		{
			case -1: 	
				perror("Erreur lors de l'exécution du fork");
				break;
			case 0:
				tmp->n = executer(tmp->n);
				exit(1);
				break;
			//Attendre la fin du fils avant de passer au noeud suivant
			default:
				sleep(1);
				waitpid(pid, &status, 0);
				break;
 		}
 		//passage au noeud suivant
		if(tmp->suiv != NULL)
			tmp=tmp->suiv;
		else
			fb = 1;
	}
	return tmp;
}

Noeud* maqueSpecifique(Noeud* node)
{
	//S'il n'y a pas de prédecesseur
	if(node->pred == NULL)
	{
		node = executer(node);
	}
	else
	{
		//Liste des prédecesseurs
		Liste* p = node->pred;
		//Int gérant l'arrêt de la boucle
		int fb = 0;
		while(fb == 0)
		{
			//S'ils ne l'ont pas été alors exec
			if(p->n->flag == 0)
				maqueSpecifique(p->n);
			//Tant qu'il y a des prédecesseurs
			if(p->suiv != NULL)
				p = p->suiv;
			else
				fb = 1;
		}
		//Exécution des commandes du noeud courant
		node = executer(node);
		sleep(1);
	}
	return node;
}

ElemPP * constructPile(Graphe * tmp)
{
	/* TODO construire la pile */
	ElemPP * res = malloc(sizeof(ElemPP));
	res->pileNode = NULL;
	res->next = NULL;
	return res;
}

int ParallelExec(int nbprocs, Graphe * tmp)
{
	ElemPP * Pilepile = constructPile(tmp);
	ElemN * Piletmp = malloc(sizeof(ElemN));
	int end = 0, i, nbproclance;
	pid_t * pids = malloc(sizeof(pid_t)* nbprocs);
	int changelevel = 0;

	//on initialise l'execution au premier niveau
	Piletmp = Pilepile->pileNode;

	while(!end)
	{
		nbproclance = 0;
		if(changelevel)
		{
			if(Pilepile->next != NULL) //passage au niveau suivant
			{
				Pilepile = Pilepile->next;
				Piletmp = Pilepile->pileNode;
				changelevel = 0;
			}
			else //on a executé le dernier niveau
			{
				end = 1;
			}
		}
		for(i = 0; i < nbprocs; i++) //Si le nombre d'exec > nbprocs, on passera deux fois dans cette boucle
		{
			switch(pids[i] = fork())
			{
				case 0: //père
					nbproclance++;
					break;
				case -1:
					perror("Erreur lors du fork");
					break;
				default:
					executer(Piletmp->n);
					break;
			}
			if(Piletmp->next != NULL) //d'autre noeud à ce niveau
				Piletmp = Piletmp->next;
			else //on a lancé toutes les executions de ce niveau
			{
				i = nbprocs;
				changelevel = 1;
			}
		}
		for(i = 0; i < nbproclance; i++)
		{
			waitpid(pids[i], 0, 0);
			nbproclance--;
		}
	}

	free(Piletmp);
	free(Pilepile);
	return 1;
}

int main( int argc, char **argv )
{
	char *maquefile="Maquefile.test3"; /* nom du maquefile par défaut */
	int numproc = 1;
	int opt;
	Noeud *ncible;

	/* analyse des arguments */
	while( (opt=getopt( argc, argv, "j:f:")) != -1 )
	{
		switch( opt )
		{
			case 'j':
				numproc = atoi(optarg);
				break;
			case 'f':
				maquefile = optarg;
				break;
			default:
				fprintf( stderr,
					"Usage: %s [-j nbprocs] [-f filename] [target]\n",
					argv[0] );
				exit(2);
		}
	}

	/* lecture du maquefile */
	Graphe *g;
	g = LireMaquefile( maquefile );
	if( g == NULL )
		exit( 1 );

	/* target */
	if( optind >= argc )
	{
		/* pas de cible spécifiée,
		 * on prend la dernière de la liste des noeuds du graphe */
		Graphe *tmp;
		tmp=g;
		tmp = maqueGeneral(tmp);
		ncible = tmp->n;
	}
	else
	{
		/* on cherche la cible spécifiée */
		char *target;
		target = argv[optind];
		if( (ncible = TrouveNoeud(g, target )) == NULL )
		{
			fprintf( stderr, "No rule to make target '%s'.\n", target );
			exit( 2 );
		}
		else
		{
			ncible = maqueSpecifique(ncible);
		}
	}

	printf( "Making. Number of procs: %d; maquefile: %s; target:%s\n",
			numproc, maquefile, ncible->nom );

	//AfficheGraphe( g );

	FreeGraphe( g );

	return( 0 );
}
